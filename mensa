#! /usr/local/bin/perl

use strict;
use warnings;

use feature 'say';
use encoding 'utf8';

use lib '/media/Share/development/perl/Mensa-Dresden/lib';

=head1 NAME

mensa - little script to check the canteen's offerings in Dresden

=head1 DESCRIPTION

=cut

use Getopt::Long;
use Mensa::Dresden ':all';
use YAML::Tiny 'LoadFile';

use subs qw(load_config);

my @canteens;
my @filters;
my @name_filters;
my @ingredient_filters;
my $tomorrow = 0;
my $show_all = 0;
my $verbose = 0;

load_config();

=head2 OPTIONS

=over 4

=item B<-c>, B<--canteen>

=back

=cut

GetOptions(
	'canteen|c=s@' => \@canteens,
	'filter-name|name|n=s@' => \@name_filters,
	'filter-ingredient|ingredient|i=s@' => \@ingredient_filters,
	'tomorrow' => \$tomorrow,
	'show-all' => \$show_all,
	'verbose' => \$verbose
);

{	# remove dublicated canteens
	my %tmp = map { $_ => 1 } @canteens;
	@canteens = keys %tmp;
}

push @filters, map { create_filter(NAME, $_, s/^~\s*//) } @name_filters;
push @filters, map {
	create_filter(INGREDIENTS, $_, s/^~\s*//) } @ingredient_filters;

@filters = () if $show_all;

for my $name (@canteens) {
	my $mensa = Mensa::Dresden->new($name, @filters);
	my @meals = $mensa->get_offering($tomorrow ? TOMORROW : TODAY);
	if (@meals) {
		say "[ $name ]\n";
		if ($verbose) {
			say $_->to_string . "\n" for @meals;
		} else {
			say $_->name for @meals;
		}
		print "\n";
	}
}

=head2 CONFIGURATION

To configure the mensa-script and avoid of passing thousands of options
to it, the script can load configurations from a YAML-file. Simply place
a new file in your home directory and name it C<.mensarc>. The script
will load it automatically. The file must have the following structure:

  --- # canteens
  - name #1
  - name #2
  - ...

  --- # filters
  name:
    - regular expression #1
    - ~ regular expression #2
  ingredients:
    - regular expression #3

The first section lists all mensas which are requested for their offering.
The second section contains all filters which were applied to each meal to
determine if it's printed or not. The questionmark in front of a regex
indicates that it must not match the expression.

=cut

sub load_config() {
	my $path = "$ENV{HOME}/.mensarc";
	return unless -f $path;

	my ($canteens, $filters) = LoadFile($path);
	@canteens = @{$canteens} if defined $canteens;

	return unless defined $filters;
	while (my ($what, $regexes) = each $filters) {
		for my $regex (@{$regexes}) {
			my $negative = $regex =~ s/^~\s*//;
			push @filters, create_filter($what, $regex, $negative);
		}
	}
}

